
get the best
  pull_best/pull_most_starred.py
    def pull(url=None, count=20):
      if url is None:
        url = 'https://api.github.com/search/repositories?q=stars:>1&s=stars&order=desc'
      print 'requesting:', url
      resp = requests.get(url, auth=config.auth_)

      results_dict = json.loads(resp.content)
      for repo_dict in results_dict['items']:
        repo_util.write_repo(repo_dict) (see below)
      print 'rate-limit remaining:', resp.headers['x-ratelimit-remaining']
      next_link = re.search('<(.+?)>', resp.headers['link']).group(1)
      if count > 0:
        count -= 1
        pull(next_link, count)

    def parse():
      with open('most_starred.json') as f:
        json_str = f.read()
      most_starred = json.loads(json_str)
      print 'num:', len(most_starred['items'])


serve.py
  @app.route('/')
  def index():
    print 'lists:', repo_lists
    return flask.render_template('index.html', repo_lists=repo_lists)
      repo_lists = {
        'web_frameworks': [
          'koajs/koa',
          ...
        ],
        ...
      }
      {% for list_name, list in repo_lists.iteritems() %}
        <li><a href='/lists/(((list_name)))'>(((list_name)))</a></li>
        def query_list(list_name):
          paths = repo_lists[list_name] if list_name in repo_lists else None
          if paths:
            repos = []
            for path in paths:
              try:
                repos.append(get_repo(path))
                  def get_repo(repo_path):
                    repo_dict = github_quality.pull_repo(repo_path, mean_stars_per_issue, auth=config.auth_)
                      repo_util.validate_path(repo_path)
                      cache_file_path = os.path.join(config.cache_dir_path, repo_path.replace('/', '_') + '.txt')
                      if not os.path.exists(cache_file_path) or ignore_cache:
                        print 'pulling info:', cache_file_path

                        main_resp = requests.get('https://api.github.com/repos/' + repo_path, auth=auth)
                        for _ in range(10):
                          if main_resp.status_code == 200:
                            print 'main xrate-limit-remaining:', main_resp.headers['x-ratelimit-remaining']
                            repo_util.write_repo(main_resp.content, mean_stars_per_issue, repo_path)
                              if isinstance(repo_dict, basestring):
                                repo_dict = json.loads(repo_dict)
                              path = repo_path if repo_path else repo_dict['full_name']
                              validate_path(path)
                              cache_file_path = os.path.join(config.cache_dir_path, path.replace('/', '_')) + '.txt'
                                cache_dir_path = os.path.expanduser('~/.github_quality')
                              if 'created_at' not in repo_dict:
                                raise BadRepoException()

                              if os.path.exists(cache_file_path):
                                with open(cache_file_path) as f:
                                  old_text = f.read()
                                old_repo_dict = json.loads(old_text)
                                repo_dict['timestamp_to_score'] = old_repo_dict.get('timestamp_to_score') or {}

                              repo_dict['path'] = path
                              repo_dict['age'] = (arrow.now() - arrow.get(repo_dict['created_at']))
                              rate_repo(repo_dict, mean_stars_per_issue)
                                score = calc_score.calc_score(repo_dict, mean_stars_per_issue)
                                  repo_dict['score'] = (
                                    repo_dict['stargazers_count'] * .01 +
                                    repo_dict['stargazers_count'] / repo_dict['age'].days * 2)

                                  if mean_stars_per_issue is not None:
                                    if repo_dict['has_issues']:
                                      issue_count = repo_dict['open_issues_count']
                                    # (can hardcode issue counts for projects which don't use github for issues)
                                    elif repo_dict['full_name'] in hardcoded_issue_counts:
                                      issue_count = hardcoded_issue_counts[repo_dict['full_name']]
                                    else:
                                      issue_count = repo_dict['stargazers_count'] / mean_stars_per_issue
                                    repo_dict['issue_count'] = issue_count
                                    repo_dict['score'] += repo_dict['stargazers_count'] / (issue_count or 1) * 20
                                    return repo_dict['score']
                                rating, explanation = score_to_rating(score)
                                rating_str = ''
                                for i in range(rating):
                                  rating_str += u'‚≠êÔ∏è' + u' '
                                if rating_str == '':
                                  rating_str = u'üí©'
                                repo_dict['rating_str'] = rating_str
                                repo_dict['explanation'] = explanation

                              now = arrow.utcnow()

                              repo_dict.setdefault('timestamp_to_score', {})
                              repo_dict['timestamp_to_score'][now.isoformat()] = repo_dict['score']
                              repo_dict['age'] = repo_dict['age'].total_seconds()

                              json_str = json.dumps(repo_dict, indent=2)
                              print 'writing repo:', cache_file_path
                              with open(cache_file_path, 'w') as f:
                                f.write(json_str)
                              return cache_file_path
                            break
                          elif main_resp.status_code == 404:
                            raise exceptions.NotFound()
                          elif main_resp.status_code == 403:
                            reset_time = main_resp.headers['X-RateLimit-Reset']
                            print 'rate limit exceeded, sleeping for 60 seconds, reset_time:', reset_time
                            time.sleep(60)
                          else:
                            print 'pull failed:', main_resp.status_code
                            print '  resp:', main_resp.content[:100]
                            raise PullFailed()
                        else:
                          raise FailedSeveralTimes()

                      with open(cache_file_path) as f:
                        json_str = f.read()
                      repo_dict = json.loads(json_str)

                      # Set default values for keys I recently added to db (and therefore might be missing).
                      repo_dict.setdefault('path', repo_path)
                      if 'age' in repo_dict:
                        repo_dict['age'] = datetime.timedelta(seconds=repo_dict['age'])
                      else:
                        repo_dict['age'] = arrow.now() - arrow.get(repo_dict['created_at'])
                      if not 'score' in repo_dict:
                        repo_util.rate_repo(repo_dict, mean_stars_per_issue)

                      return repo_dict
                    return {k: repo_dict[k] for k in (
                      'full_name', 'score', 'has_issues', 'rating_str', 'explanation', 'open_issues',
                      'stargazers_count', 'age', 'closed_issues', 'timestamp_to_score') if k in repo_dict}
              except exceptions.NotFound:
                pass
            list_json = DateTimeEncoder().encode(sorted(repos, key=lambda r: -r['score']))
            return flask.render_template('list.html', list_json=list_json)
          abort(404)
      {% endfor %}
